<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Infinite Grid Game with Fade Trail</title>
<style>
    body { margin:0; overflow:hidden; background-color:#1a1a1a; }
    canvas { display:block; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvas(){
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// 游戏设置
const GRID_SIZE = 30;
const CHARACTER_SIZE = GRID_SIZE*0.8;
const CHARACTER_COLOR = '#4CAF50';
const GRID_COLOR = '#333';
const LINE_COLOR = '#555';
const ENEMY_COLOR = '#FF4444';
const ENEMY_SIZE = GRID_SIZE*0.7;

let playerHealth = 10;
const MAX_HEALTH = 10;
const ENEMY_DAMAGE = 1;

let charX = 0, charY = 0;
let positionHistory = [];
let visitedCells = new Set();
let lastMoveTime = Date.now();

let enemies = [];
const ENEMY_SPAWN_INTERVAL = 2000;
let lastEnemySpawnTime = 0;

let cameraX = 0, cameraY = 0;
let gameOver = false;

const keys = {};
['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','KeyW','KeyA','KeyS','KeyD'].forEach(k=>keys[k]=false);

window.addEventListener('keydown', e=>{
    if(keys.hasOwnProperty(e.code)){ e.preventDefault(); keys[e.code]=true; }
    if(gameOver && e.code==='Enter') resetGame();
});
window.addEventListener('keyup', e=>{ if(keys.hasOwnProperty(e.code)) keys[e.code]=false; });

// 敌人生成
function spawnEnemy(){
    if(gameOver) return;
    const spawnDistance = 15;
    const angle = Math.random()*Math.PI*2;
    const enemyX = charX + Math.cos(angle)*spawnDistance;
    const enemyY = charY + Math.sin(angle)*spawnDistance;
    enemies.push({
        x: enemyX,
        y: enemyY,
        health: 1,
        rotation: 0,
        rotationSpeed: 0.1,
        speed: 0.25 // 合理速度
    });
}

// 更新敌人
function updateEnemies(deltaTime){
    if(gameOver) return;
    enemies.forEach(enemy=>{
        const dx = charX - enemy.x;
        const dy = charY - enemy.y;
        const distance = Math.hypot(dx, dy);
        if(distance>0){
            enemy.x += (dx/distance) * enemy.speed * deltaTime;
            enemy.y += (dy/distance) * enemy.speed * deltaTime;
        }
        enemy.rotation += enemy.rotationSpeed;
        if(distance<0.8){
            playerHealth -= ENEMY_DAMAGE;
            if(playerHealth <=0){
                playerHealth=0;
                gameOver=true;
            }
            enemy.health=0;
        }
    });
    enemies = enemies.filter(e=>e.health>0);
}

// 重置游戏
function resetGame(){
    playerHealth = MAX_HEALTH;
    gameOver=false;
    enemies=[];
    charX=0;
    charY=0;
    visitedCells=new Set();
    positionHistory=[];
    lastEnemySpawnTime=0;
    lastMoveTime=Date.now();
}

// 更新逻辑
let lastFrameTime = Date.now();
function update(){
    const now = Date.now();
    const deltaTime = (now-lastFrameTime)/16.6667; // 基于60FPS比例
    lastFrameTime = now;

    if(!gameOver){
        const prevX=charX, prevY=charY;
        if(keys.ArrowUp||keys.KeyW) charY--;
        if(keys.ArrowDown||keys.KeyS) charY++;
        if(keys.ArrowLeft||keys.KeyA) charX--;
        if(keys.ArrowRight||keys.KeyD) charX++;

        const isMoving = charX!==prevX || charY!==prevY;
        if(isMoving){
            positionHistory.unshift({x:charX,y:charY});
            if(positionHistory.length>3) positionHistory.pop();
            visitedCells.add(`${charX},${charY}`);
            lastMoveTime = now;
        } else {
            if(now - lastMoveTime > 1000){
                positionHistory=[];
            }
        }

        if(now - lastEnemySpawnTime > ENEMY_SPAWN_INTERVAL){
            spawnEnemy();
            lastEnemySpawnTime = now;
        }

        updateEnemies(deltaTime);
        cameraX = canvas.width/2 - charX*GRID_SIZE - GRID_SIZE/2;
        cameraY = canvas.height/2 - charY*GRID_SIZE - GRID_SIZE/2;
    }

    requestAnimationFrame(update);
}

// 绘制
function draw(){
    ctx.fillStyle = GRID_COLOR;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const startCol = Math.floor(-cameraX/GRID_SIZE)-1;
    const endCol = Math.floor((-cameraX+canvas.width)/GRID_SIZE)+1;
    const startRow = Math.floor(-cameraY/GRID_SIZE)-1;
    const endRow = Math.floor((-cameraY+canvas.height)/GRID_SIZE)+1;

    // 已访问格子
    ctx.fillStyle='rgba(76,175,80,0.4)';
    for(let col=startCol;col<=endCol;col++){
        for(let row=startRow;row<=endRow;row++){
            if(visitedCells.has(`${col},${row}`)){
                ctx.fillRect(col*GRID_SIZE+cameraX,row*GRID_SIZE+cameraY,GRID_SIZE,GRID_SIZE);
            }
        }
    }

    // 网格
    ctx.strokeStyle=LINE_COLOR;
    ctx.lineWidth=1;
    for(let col=startCol;col<=endCol;col++){
        const x = col*GRID_SIZE+cameraX;
        ctx.beginPath();
        ctx.moveTo(x,0);
        ctx.lineTo(x,canvas.height);
        ctx.stroke();
    }
    for(let row=startRow;row<=endRow;row++){
        const y = row*GRID_SIZE+cameraY;
        ctx.beginPath();
        ctx.moveTo(0,y);
        ctx.lineTo(canvas.width,y);
        ctx.stroke();
    }

    // 敌人
    enemies.forEach(enemy=>{
        const ex = enemy.x*GRID_SIZE+cameraX+GRID_SIZE/2;
        const ey = enemy.y*GRID_SIZE+cameraY+GRID_SIZE/2;
        ctx.fillStyle=ENEMY_COLOR;
        ctx.save();
        ctx.translate(ex,ey);
        ctx.rotate(enemy.rotation);
        ctx.beginPath();
        ctx.moveTo(0,-ENEMY_SIZE/2);
        ctx.lineTo(-ENEMY_SIZE/2,ENEMY_SIZE/2);
        ctx.lineTo(ENEMY_SIZE/2,ENEMY_SIZE/2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    });

    // 角色
    const charScreenX = charX*GRID_SIZE+cameraX+GRID_SIZE/2;
    const charScreenY = charY*GRID_SIZE+cameraY+GRID_SIZE/2;
    ctx.fillStyle = CHARACTER_COLOR;
    ctx.beginPath();
    ctx.arc(charScreenX,charScreenY,CHARACTER_SIZE/2,0,Math.PI*2);
    ctx.fill();

    // 残影
    positionHistory.forEach((pos,index)=>{
        const alpha = 0.9 - index*0.3;
        const size = CHARACTER_SIZE/2*(1-index*0.05);
        ctx.fillStyle=`rgba(76,175,80,${alpha})`;
        const tx = pos.x*GRID_SIZE+cameraX+GRID_SIZE/2;
        const ty = pos.y*GRID_SIZE+cameraY+GRID_SIZE/2;
        ctx.beginPath();
        ctx.arc(tx,ty,size,0,Math.PI*2);
        ctx.fill();
    });

    // 血条
    ctx.fillStyle='#333';
    ctx.fillRect(20,20,200,20);
    ctx.fillStyle = playerHealth>5?'#4CAF50':playerHealth>2?'#FFC107':'#F44336';
    ctx.fillRect(20,20,(playerHealth/MAX_HEALTH)*200,20);
    ctx.strokeStyle='#fff';
    ctx.lineWidth=2;
    ctx.strokeRect(20,20,200,20);
    ctx.fillStyle='#fff';
    ctx.font='14px Arial';
    ctx.fillText(`Health: ${playerHealth}/${MAX_HEALTH}`,80,34);

    // 游戏结束
    if(gameOver){
        ctx.fillStyle='rgba(0,0,0,0.7)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle='#fff';
        ctx.font='48px Arial';
        ctx.textAlign='center';
        ctx.fillText('GAME OVER',canvas.width/2,canvas.height/2);
        ctx.font='24px Arial';
        ctx.fillText('Press Enter to Restart',canvas.width/2,canvas.height/2+40);
    }

    requestAnimationFrame(draw);
}

update();
draw();
</script>
</body>
</html>
