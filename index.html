<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ç½‘æ ¼æˆ˜æ–— - è‡ªåŠ¨æ”»å‡»æ¨¡å¼</title>
<style>
    body { 
        margin: 0; 
        overflow: hidden; 
        background-color: #1a1a1a; 
        width: 100vw;
        height: 100vh;
    }
    canvas { 
        display: block; 
        position: absolute;
        top: 0;
        left: 0;
    }
    #gameOverlays {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 10;
    }
    .notification {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0,0,0,0.8);
        color: white;
        padding: 8px 16px;
        border-radius: 4px;
        font-family: Arial, sans-serif;
        font-size: 14px;
        opacity: 0;
        transition: opacity 0.3s, transform 0.3s;
        transform: translate(-50%, -20px);
        pointer-events: none;
    }
    .notification.show {
        opacity: 1;
        transform: translate(-50%, 0);
    }
    /* é€‰æ‹©èœå•é€šç”¨æ ·å¼ */
    .selectionMenu {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(30, 30, 30, 0.95);
        border-radius: 10px;
        padding: 20px;
        width: 80%;
        max-width: 400px;
        font-family: Arial, sans-serif;
        z-index: 20;
        display: none;
        pointer-events: auto;
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
    .selectionMenu h2 {
        color: #FFD700;
        text-align: center;
        margin-top: 0;
        border-bottom: 2px solid #555;
        padding-bottom: 10px;
    }
    .selectionOption {
        background-color: #333;
        border: 2px solid #555;
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 10px;
        cursor: pointer;
        transition: all 0.2s;
        color: white;
    }
    .selectionOption:hover {
        background-color: #444;
        border-color: #777;
        transform: translateY(-2px);
    }
    .selectionOption h3 {
        margin: 0 0 5px 0;
        color: #4CAF50;
    }
    .selectionOption p {
        margin: 0;
        font-size: 14px;
        color: #ddd;
    }
    /* è™šæ‹Ÿæ‘‡æ†æ ·å¼ */
    #joystick {
        position: fixed;
        bottom: 30px;
        left: 30px;
        width: 120px;
        height: 120px;
        pointer-events: auto;
        opacity: 0.7;
        display: none;
    }
    #joystickBg {
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        border-radius: 50%;
    }
    #joystickKnob {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 40px;
        height: 40px;
        background: rgba(255,255,255,0.8);
        border-radius: 50%;
        transform: translate(-50%, -50%);
    }
    /* ç­‰çº§UI */
    #levelDisplay {
        position: fixed;
        top: 20px;
        right: 20px;
        background-color: rgba(0,0,0,0.7);
        border-radius: 6px;
        padding: 8px 12px;
        color: white;
        font-family: Arial, sans-serif;
        z-index: 5;
        pointer-events: none;
    }
    #xpBar {
        height: 6px;
        background-color: #555;
        border-radius: 3px;
        margin-top: 5px;
        overflow: hidden;
    }
    #xpFill {
        height: 100%;
        background-color: #FFD700;
        width: 0%;
        transition: width 0.3s;
    }
    /* æ¸¸æˆå¼€å§‹èœå• */
    #startMenu {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(30, 30, 30, 0.95);
        border-radius: 10px;
        padding: 30px;
        width: 80%;
        max-width: 500px;
        font-family: Arial, sans-serif;
        z-index: 30;
        display: block;
        pointer-events: auto;
        box-shadow: 0 0 30px rgba(0,0,0,0.7);
    }
    #startMenu h1 {
        color: #FFD700;
        text-align: center;
        margin-top: 0;
        margin-bottom: 20px;
    }
    #startMenu p {
        color: #ddd;
        text-align: center;
        margin-bottom: 20px;
    }
    #startButton {
        background-color: #4CAF50;
        color: white;
        border: none;
        padding: 12px 24px;
        font-size: 18px;
        border-radius: 6px;
        cursor: pointer;
        display: block;
        margin: 0 auto;
        transition: background-color 0.3s;
    }
    #startButton:hover {
        background-color: #45a049;
    }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="gameOverlays">
    <div class="notification" id="notification"></div>
</div>
<!-- ç­‰çº§æ˜¾ç¤º -->
<div id="levelDisplay">
    ç­‰çº§: <span id="levelValue">1</span>
    <div id="xpBar">
        <div id="xpFill"></div>
    </div>
</div>
<!-- åˆå§‹æ”»å‡»é€‰æ‹©èœå• -->
<div id="initialAttackMenu" class="selectionMenu">
    <h2>é€‰æ‹©è‡ªåŠ¨æ”»å‡»æ–¹å¼</h2>
    <p style="color: #ddd; text-align: center; margin-bottom: 15px;">é€‰æ‹©ä½ çš„è‡ªåŠ¨æ”»å‡»èƒ½åŠ›ï¼š</p>
    <div class="selectionOption" data-choice="projectile">
        <h3>èƒ½é‡æŠ•å°„ç‰©</h3>
        <p>è‡ªåŠ¨å‘å°„ä¼¤å®³æ•Œäººçš„æŠ•å°„ç‰©ï¼ˆæœ‰å†·å´æ—¶é—´ï¼‰</p>
    </div>
    <div class="selectionOption" data-choice="slam">
        <h3>åœ°é¢é‡å‡»</h3>
        <p>è‡ªåŠ¨å¯¹é™„è¿‘æ•Œäººè¿›è¡Œå¼ºåŠ›é‡å‡»ï¼ˆæœ‰å†·å´æ—¶é—´ï¼‰</p>
    </div>
    <div class="selectionOption" data-choice="dash">
        <h3>æˆ˜æ–—å†²åˆº</h3>
        <p>è‡ªåŠ¨å‘å‰å†²åˆºï¼Œä¼¤å®³è·¯å¾„ä¸Šçš„æ•Œäººï¼ˆæœ‰å†·å´æ—¶é—´ï¼‰</p>
    </div>
</div>
<!-- å‡çº§é€‰æ‹©èœå• -->
<div id="levelUpMenu" class="selectionMenu">
    <h2>å‡çº§äº†ï¼é€‰æ‹©ä¸€ä¸ªèƒ½åŠ›</h2>
    <div class="selectionOption" data-choice="projectile">
        <h3>èƒ½é‡æŠ•å°„ç‰©</h3>
        <p>è‡ªåŠ¨å‘å°„ä¼¤å®³æ•Œäººçš„æŠ•å°„ç‰©ï¼ˆæé«˜é¢‘ç‡å’Œä¼¤å®³ï¼‰</p>
    </div>
    <div class="selectionOption" data-choice="slam">
        <h3>åœ°é¢é‡å‡»</h3>
        <p>è‡ªåŠ¨å¯¹é™„è¿‘æ•Œäººè¿›è¡Œå¼ºåŠ›é‡å‡»ï¼ˆæé«˜é¢‘ç‡å’Œä¼¤å®³èŒƒå›´ï¼‰</p>
    </div>
    <div class="selectionOption" data-choice="dash">
        <h3>æˆ˜æ–—å†²åˆº</h3>
        <p>è‡ªåŠ¨å‘å‰å†²åˆºï¼Œä¼¤å®³è·¯å¾„ä¸Šçš„æ•Œäººï¼ˆæé«˜é¢‘ç‡å’Œè·ç¦»ï¼‰</p>
    </div>
</div>
<!-- æ¸¸æˆå¼€å§‹èœå• -->
<div id="startMenu">
    <h1>ç½‘æ ¼æˆ˜æ–— - è‡ªåŠ¨æ”»å‡»æ¨¡å¼</h1>
    <p>è‡ªåŠ¨æ”»å‡»æ¨¡å¼ï¼šåªéœ€æ§åˆ¶ç§»åŠ¨ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨æ”»å‡»ï¼</p>
    <p>åœ¨æ•Œäººçš„æµªæ½®ä¸­å°½å¯èƒ½é•¿æ—¶é—´åœ°ç”Ÿå­˜ï¼å‡çº§ä»¥å˜å¾—æ›´å¼ºã€‚</p>
    <button id="startButton">å¼€å§‹æ¸¸æˆ</button>
</div>
<!-- è™šæ‹Ÿæ‘‡æ† -->
<div id="joystick">
    <div id="joystickBg"></div>
    <div id="joystickKnob"></div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const notification = document.getElementById('notification');
const levelUpMenu = document.getElementById('levelUpMenu');
const initialAttackMenu = document.getElementById('initialAttackMenu');
const startMenu = document.getElementById('startMenu');
const startButton = document.getElementById('startButton');
const levelValue = document.getElementById('levelValue');
const xpFill = document.getElementById('xpFill');

// ç”»å¸ƒè®¾ç½®
function setupCanvas() {
    const width = window.innerWidth;
    const height = window.innerHeight;
    const dpr = window.devicePixelRatio || 1;
    
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
}

function resizeCanvas() {
    setupCanvas();
    cameraX = canvas.width/2 - charX * GRID_SIZE - GRID_SIZE/2;
    cameraY = canvas.height/2 - charY * GRID_SIZE - GRID_SIZE/2;
}

setupCanvas();
window.addEventListener('resize', resizeCanvas);
window.addEventListener('orientationchange', resizeCanvas);

// æ¸¸æˆåŸºç¡€è®¾ç½®
const GRID_SIZE = 30;
const CHARACTER_SIZE = GRID_SIZE * 0.8;
const CHARACTER_COLOR = '#4CAF50';
const GRID_COLOR = '#1a1a1a';
const LINE_COLOR = '#3a3a3a';
const ENEMY_COLORS = {
    basic: '#FF4444',
    fast: '#FF9800',
    tank: '#9C27B0',
    seeker: '#03A9F4'
};
const ENEMY_SIZES = {
    basic: GRID_SIZE * 0.7,
    fast: GRID_SIZE * 0.6,
    tank: GRID_SIZE * 0.8,
    seeker: GRID_SIZE * 0.55
};

// ç­‰çº§å’Œç»éªŒç³»ç»Ÿ
let playerLevel = 1;
let currentXP = 0;
let xpToNextLevel = 100;
let availableAbilities = [];

// æ”»å‡»èƒ½åŠ›è®¾ç½® - åˆå§‹éƒ½æœªè§£é”
const abilities = {
    projectile: {
        unlocked: false,
        damage: 1,
        cooldown: 1500,
        lastUsed: 0,
        range: 8,
        speed: 0.8
    },
    slam: {
        unlocked: false,
        damage: 2,
        cooldown: 3000,
        lastUsed: 0,
        radius: 3
    },
    dash: {
        unlocked: false,
        damage: 1,
        cooldown: 2000,
        lastUsed: 0,
        distance: 5,
        speed: 2.5
    }
};

// æ”»å‡» projectile
let projectiles = [];

// é“å…·è®¾ç½®
const POWERUP_TYPES = {
    health: { color: '#4CAF50', duration: 0, effect: 'health', icon: '+' },
    speed: { color: '#2196F3', duration: 5000, effect: 'speed', icon: 'âš¡' },
    shield: { color: '#FFEB3B', duration: 8000, effect: 'shield', icon: 'ğŸ›¡ï¸' },
    blast: { color: '#F44336', duration: 0, effect: 'blast', icon: 'ğŸ’¥' },
    xpboost: { color: '#FFD700', duration: 0, effect: 'xpboost', icon: 'âœ¦' }
};
const POWERUP_SIZE = GRID_SIZE * 0.6;
const POWERUP_SPAWN_INTERVAL = 10000;
let lastPowerupSpawnTime = 0;
let powerups = [];

// ç²’å­æ•ˆæœç³»ç»Ÿ
let particles = [];

// æ¸¸æˆç³»ç»Ÿé…ç½®
const GAME_DURATION = 600;
let gameStartTime = Date.now();
let remainingTime = GAME_DURATION;
let gameWon = false;
let score = 0;
let highScore = localStorage.getItem('gridGameHighScore') || 0;
let comboMultiplier = 1;
let lastEnemyKillTime = 0;
const COMBO_TIMEOUT = 3000;

let playerHealth = 10;
let maxHealth = 10;
const BASE_SPEED = 0.5;
let playerSpeed = BASE_SPEED;

// ç©å®¶çŠ¶æ€æ•ˆæœ
let activeEffects = {
    speed: { active: false, endTime: 0 },
    shield: { active: false, endTime: 0 },
    invulnerable: { active: false, endTime: 0 },
    xpboost: { active: false, endTime: 0, multiplier: 1.5 }
};

// è§’è‰²ä½ç½®ä¸ç§»åŠ¨çŠ¶æ€
let charX = 0, charY = 0;
let positionHistory = [];
let visitedCells = new Set();
let lastMoveTime = Date.now();

// ç‰©ç†ç§»åŠ¨å‚æ•°
let moveVelocity = { x: 0, y: 0 };
const ACCELERATION = 0.06;
const DECELERATION = 0.14;
let currentMaxSpeed = BASE_SPEED * 1.1;

// æ•Œäººè®¾ç½®
let enemies = [];
let enemySpawnInterval = 2000;
let lastEnemySpawnTime = 0;
let enemyTypes = ['basic'];
let enemySpeedMultiplier = 0.6;

// ç›¸æœºè®¾ç½®
let cameraX = 0, cameraY = 0;
let gameOver = false;
let levelUpPending = false;
let gameStarted = false;
let initialAttackChosen = false;

// é”®ç›˜æ§åˆ¶
const keys = {};
['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','KeyW','KeyA','KeyS','KeyD'].forEach(k => keys[k] = false);

// è™šæ‹Ÿæ‘‡æ†æ§åˆ¶
const joystick = {
    isActive: false,
    centerX: 0,
    centerY: 0,
    radius: 60,
    dir: { x: 0, y: 0 }
};
const joystickBg = document.getElementById('joystickBg');
const joystickKnob = document.getElementById('joystickKnob');

// æ˜¾ç¤ºé€šçŸ¥
function showNotification(text, duration = 2000) {
    notification.textContent = text;
    notification.classList.add('show');
    setTimeout(() => {
        notification.classList.remove('show');
    }, duration);
}

// ç»éªŒå’Œç­‰çº§ç³»ç»Ÿ
function gainXP(amount) {
    if (activeEffects.xpboost.active) {
        amount = Math.floor(amount * activeEffects.xpboost.multiplier);
        showNotification(`+${amount} ç»éªŒå€¼ (å·²åŠ æˆ)`);
    } else {
        showNotification(`+${amount} ç»éªŒå€¼`);
    }
    
    currentXP += amount;
    
    // æ£€æŸ¥æ˜¯å¦å‡çº§
    while (currentXP >= xpToNextLevel) {
        currentXP -= xpToNextLevel;
        playerLevel++;
        levelUp();
        xpToNextLevel = Math.floor(xpToNextLevel * 1.5);
    }
    
    // æ›´æ–°UI
    updateLevelUI();
}

function levelUp() {
    showNotification(`å‡çº§äº†ï¼ç°åœ¨æ˜¯${playerLevel}çº§ï¼`, 3000);
    levelValue.textContent = playerLevel;
    
    // å‡çº§å¥–åŠ±
    playerHealth = Math.min(playerHealth + 2, maxHealth);
    
    // æ¯3çº§å¢åŠ æœ€å¤§ç”Ÿå‘½å€¼
    if (playerLevel % 3 === 0) {
        const oldMax = maxHealth;
        maxHealth += 2;
        playerHealth = maxHealth;
        showNotification(`æœ€å¤§ç”Ÿå‘½å€¼æå‡è‡³${maxHealth}ï¼`, 3000);
    }
    
    // æ˜¾ç¤ºå‡çº§é€‰æ‹©èœå•
    levelUpPending = true;
    levelUpMenu.style.display = 'block';
    gameOver = true; // æš‚åœæ¸¸æˆ
}

function updateLevelUI() {
    const xpPercentage = (currentXP / xpToNextLevel) * 100;
    xpFill.style.width = `${xpPercentage}%`;
}

// é€‰æ‹©åˆå§‹æ”»å‡»
function chooseInitialAttack(abilityType) {
    abilities[abilityType].unlocked = true;
    availableAbilities.push(abilityType);
    
    // åˆå§‹æ”»å‡»æœ‰å°å¹…å¢å¼º
    switch(abilityType) {
        case 'projectile':
            abilities.projectile.cooldown = 1200; // æ¯”å‡çº§è·å¾—çš„ç•¥å¿«
            showNotification("å·²è§£é”è‡ªåŠ¨èƒ½é‡æŠ•å°„ç‰©ï¼ç³»ç»Ÿå°†è‡ªåŠ¨å‘å°„", 4000);
            break;
        case 'slam':
            abilities.slam.cooldown = 2500; // æ¯”å‡çº§è·å¾—çš„ç•¥å¿«
            showNotification("å·²è§£é”è‡ªåŠ¨åœ°é¢é‡å‡»ï¼ç³»ç»Ÿå°†è‡ªåŠ¨è§¦å‘", 4000);
            break;
        case 'dash':
            abilities.dash.cooldown = 1700; // æ¯”å‡çº§è·å¾—çš„ç•¥å¿«
            showNotification("å·²è§£é”è‡ªåŠ¨æˆ˜æ–—å†²åˆºï¼ç³»ç»Ÿå°†è‡ªåŠ¨å‘åŠ¨", 4000);
            break;
    }
    
    initialAttackMenu.style.display = 'none';
    initialAttackChosen = true;
    gameOver = false; // å¼€å§‹æ¸¸æˆ
    gameStartTime = Date.now(); // é‡ç½®æ¸¸æˆå¼€å§‹æ—¶é—´
}

// é€‰æ‹©å‡çº§èƒ½åŠ›
function chooseAbility(abilityType) {
    // å¦‚æœå·²ç»è§£é”ï¼Œåˆ™å‡çº§
    if (abilities[abilityType].unlocked) {
        switch(abilityType) {
            case 'projectile':
                abilities.projectile.damage += 0.5;
                abilities.projectile.cooldown = Math.max(800, abilities.projectile.cooldown - 100);
                showNotification("è‡ªåŠ¨æŠ•å°„ç‰©å·²å‡çº§ï¼æ›´é«˜ä¼¤å®³ï¼Œæ›´å¿«å†·å´", 3000);
                break;
            case 'slam':
                abilities.slam.damage += 0.5;
                abilities.slam.radius += 0.2;
                abilities.slam.cooldown = Math.max(2000, abilities.slam.cooldown - 200);
                showNotification("è‡ªåŠ¨é‡å‡»å·²å‡çº§ï¼æ›´é«˜ä¼¤å®³ï¼Œæ›´å¤§èŒƒå›´", 3000);
                break;
            case 'dash':
                abilities.dash.damage += 0.5;
                abilities.dash.distance += 0.3;
                abilities.dash.cooldown = Math.max(1200, abilities.dash.cooldown - 150);
                showNotification("è‡ªåŠ¨å†²åˆºå·²å‡çº§ï¼æ›´è¿œè·ç¦»ï¼Œæ›´é«˜ä¼¤å®³", 3000);
                break;
        }
    } 
    // å¦åˆ™è§£é”æ–°èƒ½åŠ›
    else {
        abilities[abilityType].unlocked = true;
        availableAbilities.push(abilityType);
        
        switch(abilityType) {
            case 'projectile':
                showNotification("å·²è§£é”è‡ªåŠ¨èƒ½é‡æŠ•å°„ç‰©ï¼ç³»ç»Ÿå°†è‡ªåŠ¨å‘å°„", 3000);
                break;
            case 'slam':
                showNotification("å·²è§£é”è‡ªåŠ¨åœ°é¢é‡å‡»ï¼ç³»ç»Ÿå°†è‡ªåŠ¨è§¦å‘", 3000);
                break;
            case 'dash':
                showNotification("å·²è§£é”è‡ªåŠ¨æˆ˜æ–—å†²åˆºï¼ç³»ç»Ÿå°†è‡ªåŠ¨å‘åŠ¨", 3000);
                break;
        }
    }
    
    levelUpMenu.style.display = 'none';
    levelUpPending = false;
    gameOver = false; // æ¢å¤æ¸¸æˆ
}

// æ”»å‡»èƒ½åŠ›å®ç°
function fireProjectile() {
    if (!abilities.projectile.unlocked) return;
    
    const now = Date.now();
    if (now - abilities.projectile.lastUsed < abilities.projectile.cooldown) {
        return; // å†·å´ä¸­ï¼Œä¸æ‰§è¡Œ
    }
    
    abilities.projectile.lastUsed = now;
    
    // åŸºäºç§»åŠ¨æ–¹å‘æˆ–é¢å‘æ–¹å‘å‘å°„
    let directionX = moveVelocity.x;
    let directionY = moveVelocity.y;
    
    // å¦‚æœé™æ­¢ï¼Œé»˜è®¤å‘ä¸Šå‘å°„
    if (Math.hypot(directionX, directionY) < 0.1) {
        directionY = -1;
    } else {
        const dirLength = Math.hypot(directionX, directionY);
        directionX /= dirLength;
        directionY /= dirLength;
    }
    
    // å¯»æ‰¾æœ€è¿‘çš„æ•Œäººï¼Œä¼˜å…ˆå‘æ•Œäººæ–¹å‘å‘å°„
    let closestEnemy = null;
    let closestDistance = Infinity;
    enemies.forEach(enemy => {
        const dx = enemy.x - charX;
        const dy = enemy.y - charY;
        const distance = Math.hypot(dx, dy);
        
        if (distance < closestDistance && distance < abilities.projectile.range * 1.5) {
            closestDistance = distance;
            closestEnemy = enemy;
        }
    });
    
    // å¦‚æœæœ‰è¿‘è·ç¦»æ•Œäººï¼Œç„å‡†æ•Œäºº
    if (closestEnemy) {
        directionX = closestEnemy.x - charX;
        directionY = closestEnemy.y - charY;
        const dirLength = Math.hypot(directionX, directionY);
        if (dirLength > 0) {
            directionX /= dirLength;
            directionY /= dirLength;
        }
    }
    
    projectiles.push({
        x: charX,
        y: charY,
        dirX: directionX,
        dirY: directionY,
        speed: abilities.projectile.speed,
        distance: 0,
        maxDistance: abilities.projectile.range,
        damage: abilities.projectile.damage,
        size: GRID_SIZE * 0.3
    });
    
    createParticles(
        charX * GRID_SIZE + cameraX + GRID_SIZE/2,
        charY * GRID_SIZE + cameraY + GRID_SIZE/2,
        8, 'rgba(100, 200, 255, ', [1, 3]
    );
}

function performSlam() {
    if (!abilities.slam.unlocked) return;
    
    const now = Date.now();
    if (now - abilities.slam.lastUsed < abilities.slam.cooldown) {
        return; // å†·å´ä¸­ï¼Œä¸æ‰§è¡Œ
    }
    
    // åªæœ‰é™„è¿‘æœ‰æ•Œäººæ—¶æ‰æ‰§è¡Œé‡å‡»
    let enemiesInRange = false;
    enemies.forEach(enemy => {
        const dx = charX - enemy.x;
        const dy = charY - enemy.y;
        const distance = Math.hypot(dx, dy);
        
        if (distance < abilities.slam.radius * 1.5) {
            enemiesInRange = true;
        }
    });
    
    if (!enemiesInRange) return;
    
    abilities.slam.lastUsed = now;
    
    // å¯¹èŒƒå›´å†…æ•Œäººé€ æˆä¼¤å®³
    enemies.forEach(enemy => {
        const dx = charX - enemy.x;
        const dy = charY - enemy.y;
        const distance = Math.hypot(dx, dy);
        
        if (distance < abilities.slam.radius) {
            enemy.health -= abilities.slam.damage;
            createParticles(
                enemy.x * GRID_SIZE + cameraX + GRID_SIZE/2,
                enemy.y * GRID_SIZE + cameraY + GRID_SIZE/2,
                6, `${ENEMY_COLORS[enemy.type]}`, [2, 4]
            );
            
            if (enemy.health <= 0) {
                const killScore = Math.floor(enemy.scoreValue * comboMultiplier);
                score += killScore;
                gainXP(Math.floor(enemy.scoreValue / 2 * comboMultiplier));
                showNotification(`+${killScore} (è¿å‡» x${comboMultiplier.toFixed(1)})`);
                createParticles(
                    enemy.x * GRID_SIZE + cameraX + GRID_SIZE/2,
                    enemy.y * GRID_SIZE + cameraY + GRID_SIZE/2,
                    10, `${ENEMY_COLORS[enemy.type]}`, [2, 4]
                );
                updateCombo();
            }
        }
    });
    
    //  slam æ•ˆæœ
    createParticles(
        charX * GRID_SIZE + cameraX + GRID_SIZE/2,
        charY * GRID_SIZE + cameraY + GRID_SIZE/2,
        30, 'rgba(255, 150, 50, ', [2, 6], [0.5, 2]
    );
    
    // ç»˜åˆ¶ slam æ³¢çº¹
    particles.push({
        x: charX * GRID_SIZE + cameraX + GRID_SIZE/2,
        y: charY * GRID_SIZE + cameraY + GRID_SIZE/2,
        size: GRID_SIZE * 0.5,
        maxSize: GRID_SIZE * abilities.slam.radius,
        speed: 0.8,
        color: 'rgba(255, 150, 50, ',
        alpha: 0.6,
        decay: 0.03,
        isRipple: true
    });
}

function performDash() {
    if (!abilities.dash.unlocked) return;
    
    const now = Date.now();
    if (now - abilities.dash.lastUsed < abilities.dash.cooldown) {
        return; // å†·å´ä¸­ï¼Œä¸æ‰§è¡Œ
    }
    
    // åªæœ‰å‰æ–¹æœ‰æ•Œäººæˆ–éœ€è¦ç§»åŠ¨æ—¶æ‰æ‰§è¡Œå†²åˆº
    let directionX = moveVelocity.x;
    let directionY = moveVelocity.y;
    let shouldDash = false;
    
    // å¦‚æœé™æ­¢ï¼Œæ£€æŸ¥å‘¨å›´æ˜¯å¦æœ‰æ•Œäºº
    if (Math.hypot(directionX, directionY) < 0.1) {
        enemies.forEach(enemy => {
            const dx = enemy.x - charX;
            const dy = enemy.y - charY;
            const distance = Math.hypot(dx, dy);
            
            if (distance < abilities.dash.distance * 1.2) {
                directionX = dx;
                directionY = dy;
                shouldDash = true;
            }
        });
        
        // å¦‚æœæ²¡æœ‰æ•Œäººï¼Œé»˜è®¤å‘ä¸Šå†²åˆº
        if (!shouldDash) {
            directionY = -1;
            shouldDash = true; // å¶å°”éšæœºå†²åˆº
        }
    } else {
        shouldDash = true;
    }
    
    if (!shouldDash) return;
    
    abilities.dash.lastUsed = now;
    
    // å½’ä¸€åŒ–æ–¹å‘
    const dirLength = Math.hypot(directionX, directionY);
    if (dirLength > 0) {
        directionX /= dirLength;
        directionY /= dirLength;
    }
    
    // å†²åˆºè·ç¦»
    const dashDistance = abilities.dash.distance;
    
    // è®°å½•åŸå§‹ä½ç½®ç”¨äºç²’å­æ•ˆæœ
    const startX = charX;
    const startY = charY;
    
    // åº”ç”¨å†²åˆº
    charX += directionX * dashDistance;
    charY += directionY * dashDistance;
    
    // å¯¹è·¯å¾„ä¸Šçš„æ•Œäººé€ æˆä¼¤å®³
    enemies.forEach(enemy => {
        // æ£€æŸ¥æ•Œäººæ˜¯å¦åœ¨å†²åˆºè·¯å¾„ä¸Š
        const enemyVectorX = enemy.x - startX;
        const enemyVectorY = enemy.y - startY;
        const dotProduct = enemyVectorX * directionX + enemyVectorY * directionY;
        
        if (dotProduct > 0 && dotProduct < dashDistance) {
            const perpendicularDistance = Math.abs(enemyVectorX * directionY - enemyVectorY * directionX);
            
            if (perpendicularDistance < 1) {
                enemy.health -= abilities.dash.damage;
                createParticles(
                    enemy.x * GRID_SIZE + cameraX + GRID_SIZE/2,
                    enemy.y * GRID_SIZE + cameraY + GRID_SIZE/2,
                    6, `${ENEMY_COLORS[enemy.type]}`, [2, 4]
                );
                
                if (enemy.health <= 0) {
                    const killScore = Math.floor(enemy.scoreValue * comboMultiplier);
                    score += killScore;
                    gainXP(Math.floor(enemy.scoreValue / 2 * comboMultiplier));
                    showNotification(`+${killScore} (è¿å‡» x${comboMultiplier.toFixed(1)})`);
                    createParticles(
                        enemy.x * GRID_SIZE + cameraX + GRID_SIZE/2,
                        enemy.y * GRID_SIZE + cameraY + GRID_SIZE/2,
                        10, `${ENEMY_COLORS[enemy.type]}`, [2, 4]
                    );
                    updateCombo();
                }
            }
        }
    });
    
    // å†²åˆºè½¨è¿¹ç²’å­
    for (let i = 0; i < dashDistance * 3; i++) {
        const t = i / (dashDistance * 3);
        const px = startX + directionX * dashDistance * t;
        const py = startY + directionY * dashDistance * t;
        
        createParticles(
            px * GRID_SIZE + cameraX + GRID_SIZE/2,
            py * GRID_SIZE + cameraY + GRID_SIZE/2,
            3, 'rgba(150, 200, 255, ', [1, 3], [0.3, 1]
        );
    }
    
    // æ— æ•Œæ—¶é—´
    activeEffects.invulnerable.active = true;
    activeEffects.invulnerable.endTime = now + 500;
}

// è‡ªåŠ¨æ”»å‡»é€»è¾‘
function autoAttack() {
    if (gameOver || levelUpPending || !initialAttackChosen) return;
    
    // æ£€æŸ¥å¹¶æ‰§è¡Œå·²è§£é”çš„è‡ªåŠ¨æ”»å‡»
    availableAbilities.forEach(ability => {
        switch(ability) {
            case 'projectile':
                fireProjectile();
                break;
            case 'slam':
                performSlam();
                break;
            case 'dash':
                performDash();
                break;
        }
    });
}

// é”®ç›˜äº‹ä»¶ç›‘å¬
window.addEventListener('keydown', e => {
    if (keys.hasOwnProperty(e.code)) {
        e.preventDefault();
        keys[e.code] = true;
    }
    if (gameOver && !levelUpPending && e.code === 'Enter' && gameStarted) resetGame();
});
window.addEventListener('keyup', e => {
    if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
});

// åˆå§‹æ”»å‡»é€‰æ‹©
document.querySelectorAll('#initialAttackMenu .selectionOption').forEach(option => {
    option.addEventListener('click', () => {
        chooseInitialAttack(option.dataset.choice);
    });
});

// å‡çº§é€‰é¡¹é€‰æ‹©
document.querySelectorAll('#levelUpMenu .selectionOption').forEach(option => {
    option.addEventListener('click', () => {
        chooseAbility(option.dataset.choice);
    });
});

// å¼€å§‹æ¸¸æˆæŒ‰é’®
startButton.addEventListener('click', () => {
    startMenu.style.display = 'none';
    initialAttackMenu.style.display = 'block';
    gameStarted = true;
    gameOver = true; // ç­‰å¾…ç©å®¶é€‰æ‹©åˆå§‹æ”»å‡»
});

// è™šæ‹Ÿæ‘‡æ†äº‹ä»¶ç›‘å¬
joystickBg.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const rect = joystickBg.getBoundingClientRect();
    joystick.centerX = rect.left + rect.width / 2;
    joystick.centerY = rect.top + rect.height / 2;
    joystick.isActive = true;
    updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
});

document.addEventListener('touchmove', (e) => {
    if (joystick.isActive) {
        e.preventDefault();
        updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
    }
});

document.addEventListener('touchend', () => {
    if (joystick.isActive) {
        joystick.isActive = false;
        joystick.dir = { x: 0, y: 0 };
        joystickKnob.style.transform = 'translate(-50%, -50%)';
    }
});

// æ›´æ–°æ‘‡æ†æ–¹å‘å’Œä½ç½®
function updateJoystick(touchX, touchY) {
    const dx = touchX - joystick.centerX;
    const dy = touchY - joystick.centerY;
    const distance = Math.hypot(dx, dy);

    if (distance > joystick.radius) {
        const scale = joystick.radius / distance;
        joystick.dir.x = dx * scale / joystick.radius;
        joystick.dir.y = dy * scale / joystick.radius;
        joystickKnob.style.transform = `translate(${dx * scale - 20}px, ${dy * scale - 20}px)`;
    } else {
        joystick.dir.x = dx / joystick.radius;
        joystick.dir.y = dy / joystick.radius;
        joystickKnob.style.transform = `translate(${dx - 20}px, ${dy - 20}px)`;
    }
}

// ç²’å­æ•ˆæœå‡½æ•°
function createParticles(x, y, count, color, sizeRange = [2, 5], speedRange = [0.5, 2]) {
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = speedRange[0] + Math.random() * (speedRange[1] - speedRange[0]);
        const size = sizeRange[0] + Math.random() * (sizeRange[1] - sizeRange[0]);
        
        particles.push({
            x: x,
            y: y,
            size: size,
            speed: speed,
            angle: angle,
            color: color,
            alpha: 1,
            decay: 0.02 + Math.random() * 0.03,
            isRipple: false
        });
    }
}

function updateParticles(deltaTime) {
    particles.forEach((p, index) => {
        if (p.isRipple) {
            // æ³¢çº¹æ•ˆæœç‰¹æ®Šå¤„ç†
            p.size += p.speed;
            p.alpha -= p.decay;
            
            if (p.size > p.maxSize || p.alpha <= 0) {
                particles.splice(index, 1);
            }
        } else {
            p.x += Math.cos(p.angle) * p.speed * (deltaTime / 16);
            p.y += Math.sin(p.angle) * p.speed * (deltaTime / 16);
            p.alpha -= p.decay;
            
            if (p.alpha <= 0) {
                particles.splice(index, 1);
            }
        }
    });
}

function drawParticles() {
    particles.forEach(p => {
        ctx.fillStyle = `${p.color}${Math.floor(p.alpha * 255).toString(16).padStart(2, '0')}`;
        ctx.beginPath();
        if (p.isRipple) {
            ctx.strokeStyle = `${p.color}${Math.floor(p.alpha * 255).toString(16).padStart(2, '0')}`;
            ctx.lineWidth = 2;
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.stroke();
        } else {
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        }
    });
}

// æ›´æ–°æŠ•å°„ç‰©
function updateProjectiles(deltaTime) {
    projectiles.forEach((proj, index) => {
        proj.x += proj.dirX * proj.speed * deltaTime;
        proj.y += proj.dirY * proj.speed * deltaTime;
        proj.distance += proj.speed * deltaTime;
        
        // æ£€æŸ¥æ˜¯å¦è¶…å‡ºæœ€å¤§è·ç¦»
        if (proj.distance > proj.maxDistance) {
            projectiles.splice(index, 1);
            return;
        }
        
        // æ£€æŸ¥æ˜¯å¦å‡»ä¸­æ•Œäºº
        enemies.forEach((enemy, eIndex) => {
            const dx = proj.x - enemy.x;
            const dy = proj.y - enemy.y;
            const distance = Math.hypot(dx, dy);
            
            if (distance < 0.7) {
                enemy.health -= proj.damage;
                createParticles(
                    enemy.x * GRID_SIZE + cameraX + GRID_SIZE/2,
                    enemy.y * GRID_SIZE + cameraY + GRID_SIZE/2,
                    6, `${ENEMY_COLORS[enemy.type]}`, [2, 4]
                );
                
                // ç§»é™¤æŠ•å°„ç‰©
                projectiles.splice(index, 1);
                
                // æ£€æŸ¥æ•Œäººæ˜¯å¦è¢«å‡»è´¥
                if (enemy.health <= 0) {
                    const killScore = Math.floor(enemy.scoreValue * comboMultiplier);
                    score += killScore;
                    gainXP(Math.floor(enemy.scoreValue / 2 * comboMultiplier));
                    showNotification(`+${killScore} (è¿å‡» x${comboMultiplier.toFixed(1)})`);
                    createParticles(
                        enemy.x * GRID_SIZE + cameraX + GRID_SIZE/2,
                        enemy.y * GRID_SIZE + cameraY + GRID_SIZE/2,
                        10, `${ENEMY_COLORS[enemy.type]}`, [2, 4]
                    );
                    updateCombo();
                    enemies.splice(eIndex, 1);
                }
            }
        });
    });
}

// ç»˜åˆ¶æŠ•å°„ç‰©
function drawProjectiles() {
    projectiles.forEach(proj => {
        const px = proj.x * GRID_SIZE + cameraX + GRID_SIZE / 2;
        const py = proj.y * GRID_SIZE + cameraY + GRID_SIZE / 2;
        
        ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
        ctx.beginPath();
        ctx.arc(px, py, proj.size, 0, Math.PI * 2);
        ctx.fill();
        
        // è½¨è¿¹
        ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(px - proj.dirX * 10, py - proj.dirY * 10, proj.size * 0.7, 0, Math.PI * 2);
        ctx.fill();
    });
}

// æ•Œäººç”Ÿæˆå’Œæ›´æ–°å‡½æ•°
function spawnEnemy() {
    if (gameOver || levelUpPending || !initialAttackChosen) return;
    
    const gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
    if (gameTime > 90 && !enemyTypes.includes('fast')) {
        enemyTypes.push('fast');
        showNotification("å¿«é€Ÿæ•Œäººå‡ºç°äº†ï¼", 3000);
    }
    if (gameTime > 240 && !enemyTypes.includes('tank')) {
        enemyTypes.push('tank');
        showNotification("å¦å…‹æ•Œäººå‡ºç°äº†ï¼", 3000);
    }
    if (gameTime > 420 && !enemyTypes.includes('seeker')) {
        enemyTypes.push('seeker');
        showNotification("è¿½è¸ªè€…æ•Œäººå‡ºç°äº†ï¼", 3000);
    }
    
    let typeProbabilities = [];
    enemyTypes.forEach(type => {
        let weight = 1;
        if (type === 'basic') weight = Math.max(0.3, 1 - (gameTime / 600) * 0.8);
        if (type === 'fast') weight = 0.5 + (gameTime / 600) * 0.5;
        if (type === 'tank') weight = 0.3 + (gameTime / 600) * 0.7;
        if (type === 'seeker') weight = (gameTime / 600) * 0.8;
        
        for (let i = 0; i < weight * 10; i++) {
            typeProbabilities.push(type);
        }
    });
    
    const type = typeProbabilities[Math.floor(Math.random() * typeProbabilities.length)];
    
    const spawnDistance = 15 + Math.floor(gameTime / 60);
    const angle = Math.random() * Math.PI * 2;
    const enemyX = charX + Math.cos(angle) * spawnDistance;
    const enemyY = charY + Math.sin(angle) * spawnDistance;
    
    let health, speed, value, behavior, xpReward;
    switch (type) {
        case 'basic':
            health = 1;
            speed = 0.15 * enemySpeedMultiplier;
            value = 10;
            xpReward = 15;
            behavior = 'chase';
            break;
        case 'fast':
            health = 1;
            speed = 0.25 * enemySpeedMultiplier;
            value = 15;
            xpReward = 20;
            behavior = 'chase';
            break;
        case 'tank':
            health = 3;
            speed = 0.1 * enemySpeedMultiplier;
            value = 30;
            xpReward = 40;
            behavior = 'chase';
            break;
        case 'seeker':
            health = 2;
            speed = 0.2 * enemySpeedMultiplier;
            value = 25;
            xpReward = 30;
            behavior = 'predict';
            break;
    }
    
    enemies.push({
        x: enemyX,
        y: enemyY,
        health: health,
        maxHealth: health,
        rotation: 0,
        rotationSpeed: 0.1 + Math.random() * 0.1,
        speed: speed,
        type: type,
        scoreValue: value,
        xpReward: xpReward,
        behavior: behavior,
        lastSeenPlayerPos: {x: charX, y: charY},
        lastUpdateTime: Date.now()
    });
}

// é“å…·ç”Ÿæˆå’Œæ›´æ–°å‡½æ•°
function spawnPowerup() {
    if (gameOver || levelUpPending || !initialAttackChosen) return;
    
    let typeProbabilities = [];
    Object.keys(POWERUP_TYPES).forEach(type => {
        let weight = 1;
        
        if (type === 'health' && playerHealth < 5) weight = 2;
        if (type === 'shield' && activeEffects.shield.active) weight = 0.3;
        if (type === 'xpboost') weight = 0.7;
        
        for (let i = 0; i < weight * 10; i++) {
            typeProbabilities.push(type);
        }
    });
    
    const type = typeProbabilities[Math.floor(Math.random() * typeProbabilities.length)];
    
    const spawnDistance = 8 + Math.floor(Math.random() * 12);
    const angle = Math.random() * Math.PI * 2;
    const powerupX = charX + Math.cos(angle) * spawnDistance;
    const powerupY = charY + Math.sin(angle) * spawnDistance;
    
    powerups.push({
        x: powerupX,
        y: powerupY,
        type: type,
        spawnTime: Date.now(),
        lifetime: 10000,
        pulse: 0
    });
}

function applyPowerup(type) {
    const powerup = POWERUP_TYPES[type];
    switch (powerup.effect) {
        case 'health':
            const healAmount = 3;
            playerHealth = Math.min(playerHealth + healAmount, maxHealth);
            score += 5;
            showNotification(`+${healAmount} ç”Ÿå‘½å€¼ï¼`);
            createParticles(
                charX * GRID_SIZE + cameraX + GRID_SIZE/2,
                charY * GRID_SIZE + cameraY + GRID_SIZE/2,
                15, 'rgba(76, 175, 80, ', [2, 4]
            );
            break;
        case 'speed':
            activeEffects.speed.active = true;
            activeEffects.speed.endTime = Date.now() + powerup.duration;
            currentMaxSpeed = BASE_SPEED * 1.5;
            playerSpeed = BASE_SPEED * 1.3;
            score += 10;
            showNotification("é€Ÿåº¦æå‡å·²æ¿€æ´»ï¼");
            createParticles(
                charX * GRID_SIZE + cameraX + GRID_SIZE/2,
                charY * GRID_SIZE + cameraY + GRID_SIZE/2,
                30, 'rgba(33, 150, 243, ', [3, 6], [1, 3]
            );
            break;
        case 'shield':
            activeEffects.shield.active = true;
            activeEffects.shield.endTime = Date.now() + powerup.duration;
            score += 10;
            showNotification("æŠ¤ç›¾å·²æ¿€æ´»ï¼");
            createParticles(
                charX * GRID_SIZE + cameraX + GRID_SIZE/2,
                charY * GRID_SIZE + cameraY + GRID_SIZE/2,
                25, 'rgba(255, 235, 59, ', [2, 6]
            );
            break;
        case 'blast':
            score += 15;
            showNotification("çˆ†ç‚¸ï¼æ•Œäººå·²æ¶ˆç­ï¼");
            createParticles(
                charX * GRID_SIZE + cameraX + GRID_SIZE/2,
                charY * GRID_SIZE + cameraY + GRID_SIZE/2,
                40, 'rgba(244, 67, 54, ', [3, 8]
            );
            
            const blastRadius = 5;
            enemies = enemies.filter(enemy => {
                const dx = charX - enemy.x;
                const dy = charY - enemy.y;
                const distance = Math.hypot(dx, dy);
                
                if (distance < blastRadius) {
                    createParticles(
                        enemy.x * GRID_SIZE + cameraX + GRID_SIZE/2,
                        enemy.y * GRID_SIZE + cameraY + GRID_SIZE/2,
                        10, `${ENEMY_COLORS[enemy.type]}`, [2, 4]
                    );
                    score += enemy.scoreValue;
                    gainXP(enemy.xpReward / 2);
                    updateCombo();
                    return false;
                }
                return true;
            });
            break;
        case 'xpboost':
            activeEffects.xpboost.active = true;
            activeEffects.xpboost.endTime = Date.now() + 10000;
            showNotification("ç»éªŒå€¼æå‡ï¼10ç§’å†…è·å¾—50%é¢å¤–ç»éªŒï¼");
            createParticles(
                charX * GRID_SIZE + cameraX + GRID_SIZE/2,
                charY * GRID_SIZE + cameraY + GRID_SIZE/2,
                20, 'rgba(255, 215, 0, ', [2, 5]
            );
            break;
    }
}

// è¿å‡»ç³»ç»Ÿ
function updateCombo() {
    const now = Date.now();
    if (now - lastEnemyKillTime < COMBO_TIMEOUT) {
        comboMultiplier = Math.min(comboMultiplier + 0.2, 3);
    } else {
        comboMultiplier = 1;
    }
    lastEnemyKillTime = now;
    
    if (comboMultiplier > 1) {
        showNotification(`è¿å‡» x${comboMultiplier.toFixed(1)}ï¼`);
    }
}

// æ•Œäººæ›´æ–°
function updateEnemies(deltaTime) {
    if (gameOver || levelUpPending || !initialAttackChosen) return;
    
    const now = Date.now();
    enemies.forEach(enemy => {
        let targetX, targetY;
        
        switch (enemy.behavior) {
            case 'chase':
                targetX = charX;
                targetY = charY;
                break;
            case 'predict':
                const predictionTime = 1200;
                if (now - enemy.lastUpdateTime > 300) {
                    enemy.lastSeenPlayerPos = {x: charX, y: charY};
                    enemy.lastUpdateTime = now;
                }
                
                const moveVectorX = charX - enemy.lastSeenPlayerPos.x;
                const moveVectorY = charY - enemy.lastSeenPlayerPos.y;
                const moveDistance = Math.hypot(moveVectorX, moveVectorY);
                
                if (moveDistance > 0.1) {
                    const predictionFactor = predictionTime / 300;
                    targetX = charX + (moveVectorX / moveDistance) * enemy.speed * predictionFactor;
                    targetY = charY + (moveVectorY / moveDistance) * enemy.speed * predictionFactor;
                } else {
                    targetX = charX;
                    targetY = charY;
                }
                break;
        }
        
        const dx = targetX - enemy.x;
        const dy = targetY - enemy.y;
        const distance = Math.hypot(dx, dy);
        
        if (distance > 0) {
            enemy.x += (dx / distance) * enemy.speed * deltaTime;
            enemy.y += (dy / distance) * enemy.speed * deltaTime;
        }
        
        enemy.rotation += enemy.rotationSpeed;
        
        const playerDistance = Math.hypot(charX - enemy.x, charY - enemy.y);
        if (playerDistance < 0.8) {
            if (activeEffects.shield.active) {
                enemy.health = 0;
                const shieldScore = Math.floor(enemy.scoreValue * comboMultiplier / 2);
                score += shieldScore;
                gainXP(Math.floor(enemy.xpReward * comboMultiplier / 4));
                if (shieldScore > 0) {
                    showNotification(`+${shieldScore} (æŠ¤ç›¾)`);
                }
                createParticles(
                    enemy.x * GRID_SIZE + cameraX + GRID_SIZE/2,
                    enemy.y * GRID_SIZE + cameraY + GRID_SIZE/2,
                    10, `${ENEMY_COLORS[enemy.type]}`, [2, 4]
                );
                updateCombo();
            } else if (activeEffects.invulnerable.active) {
                enemy.health -= 1;
                if (enemy.health <= 0) {
                    const killScore = Math.floor(enemy.scoreValue * comboMultiplier);
                    score += killScore;
                    gainXP(Math.floor(enemy.xpReward * comboMultiplier));
                    showNotification(`+${killScore} (è¿å‡» x${comboMultiplier.toFixed(1)})`);
                    createParticles(
                        enemy.x * GRID_SIZE + cameraX + GRID_SIZE/2,
                        enemy.y * GRID_SIZE + cameraY + GRID_SIZE/2,
                        10, `${ENEMY_COLORS[enemy.type]}`, [2, 4]
                    );
                    updateCombo();
                }
            } else {
                const damageMap = { basic: 1, fast: 1, tank: 2, seeker: 1 };
                const damage = damageMap[enemy.type] || 1;
                playerHealth -= damage;
                
                activeEffects.invulnerable.active = true;
                activeEffects.invulnerable.endTime = now + 1000;
                
                if (playerHealth <= 0) {
                    playerHealth = 0;
                    gameOver = true;
                    createParticles(
                        charX * GRID_SIZE + cameraX + GRID_SIZE/2,
                        charY * GRID_SIZE + cameraY + GRID_SIZE/2,
                        50, 'rgba(255, 0, 0, ', [3, 8]
                    );
                } else {
                    showNotification(`- ${damage} ç”Ÿå‘½å€¼ï¼`);
                    createParticles(
                        charX * GRID_SIZE + cameraX + GRID_SIZE/2,
                        charY * GRID_SIZE + cameraY + GRID_SIZE/2,
                        20, 'rgba(255, 0, 0, ', [2, 5]
                    );
                }
                
                enemy.health -= 1;
                if (enemy.health <= 0) {
                    const killScore = Math.floor(enemy.scoreValue * comboMultiplier);
                    score += killScore;
                    gainXP(Math.floor(enemy.xpReward * comboMultiplier));
                    showNotification(`+${killScore} (è¿å‡» x${comboMultiplier.toFixed(1)})`);
                    createParticles(
                        enemy.x * GRID_SIZE + cameraX + GRID_SIZE/2,
                        enemy.y * GRID_SIZE + cameraY + GRID_SIZE/2,
                        10, `${ENEMY_COLORS[enemy.type]}`, [2, 4]
                    );
                    updateCombo();
                }
            }
        }
    });
    
    enemies = enemies.filter(e => e.health > 0);
}

// é“å…·æ›´æ–°
function updatePowerups() {
    if (gameOver || levelUpPending || !initialAttackChosen) return;
    
    powerups.forEach(powerup => {
        powerup.pulse = Math.sin((Date.now() - powerup.spawnTime) / 500) * 0.3 + 0.7;
    });
    
    powerups.forEach((powerup, index) => {
        const dx = charX - powerup.x;
        const dy = charY - powerup.y;
        const distance = Math.hypot(dx, dy);
        
        if (distance < 1) {
            applyPowerup(powerup.type);
            powerups.splice(index, 1);
        }
    });
    
    const now = Date.now();
    powerups = powerups.filter(p => now - p.spawnTime < p.lifetime);
}

// ç©å®¶çŠ¶æ€æ•ˆæœæ›´æ–°
function updatePlayerEffects() {
    const now = Date.now();
    
    if (activeEffects.speed.active) {
        if (now > activeEffects.speed.endTime) {
            activeEffects.speed.active = false;
            currentMaxSpeed = BASE_SPEED * 1.1;
            playerSpeed = BASE_SPEED;
            showNotification("é€Ÿåº¦æå‡ç»“æŸ");
        } else {
            const remaining = Math.ceil((activeEffects.speed.endTime - now) / 1000);
            if (remaining <= 3 && remaining % 1 === 0) {
                showNotification(`é€Ÿåº¦æå‡ï¼š${remaining}ç§’`);
            }
        }
    }
    
    if (activeEffects.shield.active) {
        if (now > activeEffects.shield.endTime) {
            activeEffects.shield.active = false;
            showNotification("æŠ¤ç›¾ç»“æŸ");
        } else {
            const remaining = Math.ceil((activeEffects.shield.endTime - now) / 1000);
            if (remaining <= 3 && remaining % 1 === 0) {
                showNotification(`æŠ¤ç›¾ï¼š${remaining}ç§’`);
            }
        }
    }
    
    if (activeEffects.invulnerable.active && now > activeEffects.invulnerable.endTime) {
        activeEffects.invulnerable.active = false;
    }
    
    if (activeEffects.xpboost.active) {
        if (now > activeEffects.xpboost.endTime) {
            activeEffects.xpboost.active = false;
            showNotification("ç»éªŒå€¼æå‡ç»“æŸ");
        } else {
            const remaining = Math.ceil((activeEffects.xpboost.endTime - now) / 1000);
            if (remaining <= 3 && remaining % 1 === 0) {
                showNotification(`ç»éªŒå€¼æå‡ï¼š${remaining}ç§’`);
            }
        }
    }
}

// éš¾åº¦å¢åŠ 
function increaseDifficulty() {
    const gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
    
    enemySpeedMultiplier = 0.6 + (gameTime / 600) * 1.8;
    if (enemySpeedMultiplier > 2.4) enemySpeedMultiplier = 2.4;
    
    enemySpawnInterval = Math.max(500, 2000 - (gameTime / 600) * 1300);
    
    if (gameTime === 60) showNotification("å·²è¿‡å»1åˆ†é’Ÿï¼", 3000);
    if (gameTime === 180) showNotification("å·²è¿‡å»3åˆ†é’Ÿï¼", 3000);
    if (gameTime === 300) showNotification("å·²è¿‡å»5åˆ†é’Ÿï¼", 3000);
    if (gameTime === 420) showNotification("å·²è¿‡å»7åˆ†é’Ÿï¼", 3000);
    if (gameTime === 540) showNotification("å·²è¿‡å»9åˆ†é’Ÿï¼", 3000);
}

// é‡ç½®æ¸¸æˆ
function resetGame() {
    if (score > highScore) {
        highScore = Math.floor(score);
        localStorage.setItem('gridGameHighScore', highScore);
        showNotification(`æ–°çš„æœ€é«˜åˆ†ï¼š${highScore}ï¼`, 5000);
    }
    
    // é‡ç½®ç©å®¶çŠ¶æ€
    playerHealth = maxHealth;
    playerSpeed = BASE_SPEED;
    currentMaxSpeed = BASE_SPEED * 1.1;
    gameOver = false;
    gameWon = false;
    score = 0;
    comboMultiplier = 1;
    
    // é‡ç½®ç­‰çº§ç³»ç»Ÿ
    playerLevel = 1;
    currentXP = 0;
    xpToNextLevel = 100;
    availableAbilities = [];
    for (const key in abilities) {
        abilities[key].unlocked = false;
    }
    updateLevelUI();
    levelValue.textContent = playerLevel;
    
    // é‡ç½®æœ€å¤§ç”Ÿå‘½å€¼
    maxHealth = 10;
    
    // æ¸…ç©ºå®ä½“
    enemies = [];
    powerups = [];
    particles = [];
    projectiles = [];
    
    // é‡ç½®ä½ç½®å’Œç§»åŠ¨
    charX = 0;
    charY = 0;
    moveVelocity = { x: 0, y: 0 };
    visitedCells = new Set();
    positionHistory = [];
    lastEnemySpawnTime = 0;
    lastPowerupSpawnTime = 0;
    lastMoveTime = Date.now();
    lastEnemyKillTime = 0;
    
    // é‡ç½®æ¸¸æˆçŠ¶æ€
    enemySpawnInterval = 2000;
    enemySpeedMultiplier = 0.6;
    enemyTypes = ['basic'];
    activeEffects = {
        speed: { active: false, endTime: 0 },
        shield: { active: false, endTime: 0 },
        invulnerable: { active: false, endTime: 0 },
        xpboost: { active: false, endTime: 0, multiplier: 1.5 }
    };
    
    // æ˜¾ç¤ºåˆå§‹æ”»å‡»é€‰æ‹©èœå•
    initialAttackMenu.style.display = 'block';
    initialAttackChosen = false;
    gameStartTime = Date.now();
    remainingTime = GAME_DURATION;
    levelUpMenu.style.display = 'none';
    levelUpPending = false;
}

// æ›´æ–°é€»è¾‘
let lastFrameTime = Date.now();
function update() {
    const now = Date.now();
    const deltaTime = (now - lastFrameTime) / 16.6667;
    lastFrameTime = now;

    if (!gameOver && !levelUpPending && initialAttackChosen) {
        // æ‰§è¡Œè‡ªåŠ¨æ”»å‡»
        autoAttack();
        
        remainingTime = GAME_DURATION - Math.floor((now - gameStartTime) / 1000);
        if (remainingTime <= 0) {
            gameOver = true;
            gameWon = playerHealth > 0;
        }

        score += deltaTime / 60;

        const prevX = charX, prevY = charY;
        
        // ç§»åŠ¨é€»è¾‘
        let targetDir = { x: 0, y: 0 };
        
        // ä¼˜å…ˆä½¿ç”¨æ‘‡æ†æ–¹å‘
        if (joystick.isActive) {
            targetDir = joystick.dir;
        } 
        // å¦åˆ™ä½¿ç”¨é”®ç›˜æ–¹å‘
        else {
            if (keys.ArrowLeft || keys.KeyA) targetDir.x = -1;
            if (keys.ArrowRight || keys.KeyD) targetDir.x = 1;
            if (keys.ArrowUp || keys.KeyW) targetDir.y = -1;
            if (keys.ArrowDown || keys.KeyS) targetDir.y = 1;
        }

        // å½’ä¸€åŒ–æ–¹å‘
        const dirLength = Math.hypot(targetDir.x, targetDir.y);
        if (dirLength > 0) {
            targetDir.x /= dirLength;
            targetDir.y /= dirLength;
        }

        // åŠ é€Ÿåº¦
        if (dirLength > 0) {
            moveVelocity.x += targetDir.x * ACCELERATION;
            moveVelocity.y += targetDir.y * ACCELERATION;
            
            // é™åˆ¶æœ€å¤§é€Ÿåº¦
            const currentSpeed = Math.hypot(moveVelocity.x, moveVelocity.y);
            if (currentSpeed > currentMaxSpeed) {
                const scale = currentMaxSpeed / currentSpeed;
                moveVelocity.x *= scale;
                moveVelocity.y *= scale;
            }
        } 
        // å‡é€Ÿåº¦
        else {
            moveVelocity.x *= (1 - DECELERATION);
            moveVelocity.y *= (1 - DECELERATION);
            
            if (Math.abs(moveVelocity.x) < 0.01) moveVelocity.x = 0;
            if (Math.abs(moveVelocity.y) < 0.01) moveVelocity.y = 0;
        }

        // åº”ç”¨é€Ÿåº¦
        charX += moveVelocity.x * deltaTime;
        charY += moveVelocity.y * deltaTime;

        // è®°å½•ç§»åŠ¨å†å²
        const isMoving = Math.abs(charX - prevX) > 0.01 || Math.abs(charY - prevY) > 0.01;
        if (isMoving) {
            positionHistory.unshift({ x: charX, y: charY });
            if (positionHistory.length > 15) positionHistory.pop();
            const cellX = Math.floor(charX);
            const cellY = Math.floor(charY);
            visitedCells.add(`${cellX},${cellY}`);
            lastMoveTime = now;
        } else {
            if (now - lastMoveTime > 1000) {
                positionHistory = [];
            }
        }

        // æ•Œäººç”Ÿæˆ
        if (now - lastEnemySpawnTime > enemySpawnInterval) {
            spawnEnemy();
            const gameTime = Math.floor((now - gameStartTime) / 1000);
            const multiSpawnChance = Math.min(0.4, gameTime / 600 * 0.4);
            if (Math.random() < multiSpawnChance && enemyTypes.length > 1) {
                spawnEnemy();
            }
            lastEnemySpawnTime = now;
        }

        // é“å…·ç”Ÿæˆ
        if (now - lastPowerupSpawnTime > POWERUP_SPAWN_INTERVAL) {
            spawnPowerup();
            if (playerHealth < 4) {
                setTimeout(spawnPowerup, 2000);
            }
            lastPowerupSpawnTime = now;
        }

        // æ›´æ–°æŠ•å°„ç‰©
        updateProjectiles(deltaTime);
        
        // ç³»ç»Ÿæ›´æ–°
        updateEnemies(deltaTime);
        updatePowerups();
        updatePlayerEffects();
        updateParticles(deltaTime);
        increaseDifficulty();
        
        // ç›¸æœºè·Ÿéš
        const targetCameraX = canvas.width/2 - charX * GRID_SIZE - GRID_SIZE/2;
        const targetCameraY = canvas.height/2 - charY * GRID_SIZE - GRID_SIZE/2;
        cameraX += (targetCameraX - cameraX) * 0.1;
        cameraY += (targetCameraY - cameraY) * 0.1;
    }

    requestAnimationFrame(update);
}

// ç»˜åˆ¶å‡½æ•°
function draw() {
    ctx.fillStyle = GRID_COLOR;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const startCol = Math.floor(-cameraX / GRID_SIZE) - 1;
    const endCol = Math.floor((-cameraX + canvas.width) / GRID_SIZE) + 1;
    const startRow = Math.floor(-cameraY / GRID_SIZE) - 1;
    const endRow = Math.floor((-cameraY + canvas.height) / GRID_SIZE) + 1;

    // ç»˜åˆ¶è®¿é—®è¿‡çš„å•å…ƒæ ¼
    ctx.fillStyle = 'rgba(76,175,80,0.1)';
    for (let col = startCol; col <= endCol; col++) {
        for (let row = startRow; row <= endRow; row++) {
            if (visitedCells.has(`${col},${row}`)) {
                ctx.fillRect(col * GRID_SIZE + cameraX, row * GRID_SIZE + cameraY, GRID_SIZE, GRID_SIZE);
            }
        }
    }

    // ç»˜åˆ¶ç½‘æ ¼çº¿
    ctx.lineWidth = 1;
    for (let col = startCol; col <= endCol; col++) {
        const x = col * GRID_SIZE + cameraX;
        const distance = Math.abs(col - charX);
        const alpha = Math.max(0.1, 1 - distance / 30);
        ctx.strokeStyle = `rgba(58, 58, 58, ${alpha})`;
        
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    for (let row = startRow; row <= endRow; row++) {
        const y = row * GRID_SIZE + cameraY;
        const distance = Math.abs(row - charY);
        const alpha = Math.max(0.1, 1 - distance / 30);
        ctx.strokeStyle = `rgba(58, 58, 58, ${alpha})`;
        
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }

    // ç»˜åˆ¶é“å…·
    powerups.forEach(powerup => {
        const px = powerup.x * GRID_SIZE + cameraX + GRID_SIZE / 2;
        const py = powerup.y * GRID_SIZE + cameraY + GRID_SIZE / 2;
        const type = POWERUP_TYPES[powerup.type];
        
        const age = Date.now() - powerup.spawnTime;
        let alpha = 1;
        if (age > powerup.lifetime - 3000) {
            alpha = 0.4 + Math.sin(age * 0.005) * 0.6;
        }
        
        const sizeMultiplier = 1 + powerup.pulse * 0.2;
        
        ctx.fillStyle = `rgba(${hexToRgb(type.color)}, ${alpha * 0.3})`;
        ctx.beginPath();
        ctx.arc(px, py, POWERUP_SIZE / 2 * sizeMultiplier, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = `rgba(${hexToRgb(type.color)}, ${alpha})`;
        ctx.beginPath();
        ctx.arc(px, py, POWERUP_SIZE / 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'white';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(type.icon, px, py);
    });

    // ç»˜åˆ¶æ•Œäºº
    enemies.forEach(enemy => {
        const ex = enemy.x * GRID_SIZE + cameraX + GRID_SIZE / 2;
        const ey = enemy.y * GRID_SIZE + cameraY + GRID_SIZE / 2;
        ctx.fillStyle = ENEMY_COLORS[enemy.type];
        ctx.save();
        ctx.translate(ex, ey);
        ctx.rotate(enemy.rotation);
        
        if (enemy.type === 'basic') {
            ctx.beginPath();
            ctx.moveTo(0, -ENEMY_SIZES.basic / 2);
            ctx.lineTo(-ENEMY_SIZES.basic / 2, ENEMY_SIZES.basic / 2);
            ctx.lineTo(ENEMY_SIZES.basic / 2, ENEMY_SIZES.basic / 2);
            ctx.closePath();
        } else if (enemy.type === 'fast') {
            ctx.beginPath();
            ctx.rect(-ENEMY_SIZES.fast / 2, -ENEMY_SIZES.fast / 2, ENEMY_SIZES.fast, ENEMY_SIZES.fast);
            ctx.closePath();
        } else if (enemy.type === 'tank') {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, ENEMY_SIZES.tank / 2, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.fillStyle = ENEMY_COLORS.tank;
            ctx.beginPath();
            ctx.arc(0, 0, (ENEMY_SIZES.tank / 2) * (enemy.health / enemy.maxHealth), 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'white';
            ctx.font = '8px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(enemy.health, 0, 0);
        } else if (enemy.type === 'seeker') {
            ctx.fillStyle = ENEMY_COLORS.seeker;
            ctx.beginPath();
            ctx.arc(0, 0, ENEMY_SIZES.seeker / 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            const playerAngle = Math.atan2(charY - enemy.y, charX - enemy.x);
            ctx.rotate(playerAngle);
            ctx.beginPath();
            ctx.moveTo(0, -ENEMY_SIZES.seeker / 2);
            ctx.lineTo(-ENEMY_SIZES.seeker / 4, ENEMY_SIZES.seeker / 4);
            ctx.lineTo(ENEMY_SIZES.seeker / 4, ENEMY_SIZES.seeker / 4);
            ctx.closePath();
            ctx.fill();
        }
        
        ctx.fill();
        ctx.restore();
    });

    // ç»˜åˆ¶æŠ•å°„ç‰©
    drawProjectiles();

    // ç»˜åˆ¶è§’è‰²
    const charScreenX = charX * GRID_SIZE + cameraX + GRID_SIZE / 2;
    const charScreenY = charY * GRID_SIZE + cameraY + GRID_SIZE / 2;
    
    // ç»˜åˆ¶æŠ¤ç›¾
    if (activeEffects.shield.active) {
        const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.1;
        ctx.strokeStyle = 'rgba(255, 235, 59, 0.7)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(charScreenX, charScreenY, (CHARACTER_SIZE / 2 + 5) * pulse, 0, Math.PI * 2);
        ctx.stroke();
    }
    
    // XP æå‡æ•ˆæœ
    if (activeEffects.xpboost.active) {
        const pulse = 1 + Math.sin(Date.now() * 0.01) * 0.05;
        ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(charScreenX, charScreenY, (CHARACTER_SIZE / 2 + 10) * pulse, 0, Math.PI * 2);
        ctx.stroke();
    }
    
    // æ— æ•ŒçŠ¶æ€é—ªçƒæ•ˆæœ
    let drawCharacter = true;
    if (activeEffects.invulnerable.active) {
        const flashRate = 100;
        drawCharacter = Math.floor(Date.now() / flashRate) % 2 === 0;
    }
    
    // ç»˜åˆ¶è§’è‰²ä¸»ä½“
    if (drawCharacter) {
        ctx.fillStyle = activeEffects.speed.active ? '#2196F3' : CHARACTER_COLOR;
        ctx.beginPath();
        ctx.arc(charScreenX, charScreenY, CHARACTER_SIZE / 2, 0, Math.PI * 2);
        ctx.fill();
        
        // ç»˜åˆ¶æ–¹å‘æŒ‡ç¤ºå™¨
        const currentSpeed = Math.hypot(moveVelocity.x, moveVelocity.y);
        if (currentSpeed > 0.05) {
            const moveAngle = Math.atan2(moveVelocity.y, moveVelocity.x);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.save();
            ctx.translate(charScreenX, charScreenY);
            ctx.rotate(moveAngle);
            
            // ç»˜åˆ¶å°ç®­å¤´
            ctx.beginPath();
            ctx.moveTo(CHARACTER_SIZE / 3, 0);
            ctx.lineTo(-CHARACTER_SIZE / 6, -CHARACTER_SIZE / 6);
            ctx.lineTo(-CHARACTER_SIZE / 6, CHARACTER_SIZE / 6);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
    }

    // ç»˜åˆ¶åŠ¨æ€è½¨è¿¹
    const currentSpeed = Math.hypot(moveVelocity.x, moveVelocity.y);
    const trailLength = Math.max(3, Math.min(8, Math.floor(currentSpeed * 15)));
    
    positionHistory.slice(0, trailLength).forEach((pos, index) => {
        const alpha = 0.9 - (index / trailLength) * 0.8;
        const size = CHARACTER_SIZE / 2 * (1 - (index / trailLength) * 0.3);
        const speedBrightness = Math.min(1, currentSpeed / currentMaxSpeed);
        const color = activeEffects.speed.active 
            ? `rgba(33, 150, 243, ${alpha * (0.8 + speedBrightness * 0.2)})` 
            : `rgba(76, 175, 80, ${alpha * (0.8 + speedBrightness * 0.2)})`;
        
        ctx.fillStyle = color;
        const tx = pos.x * GRID_SIZE + cameraX + GRID_SIZE / 2;
        const ty = pos.y * GRID_SIZE + cameraY + GRID_SIZE / 2;
        ctx.beginPath();
        ctx.arc(tx, ty, size, 0, Math.PI * 2);
        ctx.fill();
    });

    // ç»˜åˆ¶ç²’å­
    drawParticles();

    // ç»˜åˆ¶èƒ½åŠ›å†·å´æç¤º
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    let abilityX = 20;
    const abilityY = canvas.height - 60;
    const abilitySize = 40;
    
    if (abilities.projectile.unlocked) {
        const now = Date.now();
        const cooldownPercent = Math.min(1, (now - abilities.projectile.lastUsed) / abilities.projectile.cooldown);
        
        ctx.fillRect(abilityX, abilityY, abilitySize, abilitySize);
        ctx.fillStyle = cooldownPercent < 1 ? 'rgba(100, 100, 100, 0.7)' : '#fff';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('âš¡', abilityX + abilitySize/2, abilityY + abilitySize/2);
        
        if (cooldownPercent < 1) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(
                abilityX, 
                abilityY + abilitySize * cooldownPercent, 
                abilitySize, 
                abilitySize * (1 - cooldownPercent)
            );
        }
        
        abilityX += abilitySize + 10;
    }
    
    if (abilities.slam.unlocked) {
        const now = Date.now();
        const cooldownPercent = Math.min(1, (now - abilities.slam.lastUsed) / abilities.slam.cooldown);
        
        ctx.fillRect(abilityX, abilityY, abilitySize, abilitySize);
        ctx.fillStyle = cooldownPercent < 1 ? 'rgba(100, 100, 100, 0.7)' : '#fff';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('ğŸ’¥', abilityX + abilitySize/2, abilityY + abilitySize/2);
        
        if (cooldownPercent < 1) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(
                abilityX, 
                abilityY + abilitySize * cooldownPercent, 
                abilitySize, 
                abilitySize * (1 - cooldownPercent)
            );
        }
        
        abilityX += abilitySize + 10;
    }
    
    if (abilities.dash.unlocked) {
        const now = Date.now();
        const cooldownPercent = Math.min(1, (now - abilities.dash.lastUsed) / abilities.dash.cooldown);
        
        ctx.fillRect(abilityX, abilityY, abilitySize, abilitySize);
        ctx.fillStyle = cooldownPercent < 1 ? 'rgba(100, 100, 100, 0.7)' : '#fff';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('â†—ï¸', abilityX + abilitySize/2, abilityY + abilitySize/2);
        
        if (cooldownPercent < 1) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(
                abilityX, 
                abilityY + abilitySize * cooldownPercent, 
                abilitySize, 
                abilitySize * (1 - cooldownPercent)
            );
        }
        
        abilityX += abilitySize + 10;
    }

    // ç»˜åˆ¶UIå…ƒç´ 
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(20, 20, 200, 20);
    const healthColor = playerHealth > 5 ? '#4CAF50' : playerHealth > 2 ? '#FFC107' : '#F44336';
    ctx.fillStyle = healthColor;
    ctx.fillRect(20, 20, (playerHealth / maxHealth) * 200, 20);
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.strokeRect(20, 20, 200, 20);
    
    ctx.fillStyle = '#fff';
    ctx.font = '14px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`ç”Ÿå‘½å€¼: ${playerHealth}/${maxHealth}`, 25, 34);
    
    const minutes = Math.floor(remainingTime / 60);
    const seconds = remainingTime % 60;
    const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    ctx.fillText(`æ—¶é—´: ${timeString}`, 240, 34);
    
    ctx.fillText(`åˆ†æ•°: ${Math.floor(score)}`, 240, 59);
    ctx.fillText(`æœ€é«˜åˆ†: ${highScore}`, 240, 84);
    
    if (comboMultiplier > 1) {
        ctx.fillStyle = `rgba(255, 152, 0, ${0.5 + Math.sin(Date.now() * 0.005) * 0.2})`;
        ctx.font = 'bold 14px Arial';
        ctx.fillText(`è¿å‡» x${comboMultiplier.toFixed(1)}`, 240, 109);
    }
    
    let effectText = [];
    if (activeEffects.speed.active) {
        const remaining = Math.ceil((activeEffects.speed.endTime - Date.now()) / 1000);
        effectText.push(`é€Ÿåº¦æå‡ (${remaining}ç§’)`);
    }
    if (activeEffects.shield.active) {
        const remaining = Math.ceil((activeEffects.shield.endTime - Date.now()) / 1000);
        effectText.push(`æŠ¤ç›¾ (${remaining}ç§’)`);
    }
    if (activeEffects.xpboost.active) {
        const remaining = Math.ceil((activeEffects.xpboost.endTime - Date.now()) / 1000);
        effectText.push(`ç»éªŒæå‡ (${remaining}ç§’)`);
    }
    
    if (effectText.length > 0) {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(20, 55, 200, 20);
        ctx.fillStyle = '#fff';
        ctx.fillText(`æ•ˆæœ: ${effectText.join(', ')}`, 25, 69);
    }

    // æ¸¸æˆç»“æŸç”»é¢
    if (gameOver && !levelUpPending && gameStarted) {
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = gameWon ? '#4CAF50' : '#F44336';
        ctx.font = '48px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(gameWon ? 'ä»»åŠ¡æˆåŠŸï¼' : 'æ¸¸æˆç»“æŸ', canvas.width / 2, canvas.height / 2 - 40);
        
        ctx.fillStyle = '#fff';
        ctx.font = '24px Arial';
        ctx.fillText(`æœ€ç»ˆå¾—åˆ†: ${Math.floor(score)}`, canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText(`è¾¾åˆ°ç­‰çº§: ${playerLevel}`, canvas.width / 2, canvas.height / 2 + 50);
        
        if (Math.floor(score) === parseInt(highScore) && score > 0) {
            ctx.fillStyle = '#FFEB3B';
            ctx.font = '24px Arial';
            ctx.fillText('æ–°çš„æœ€é«˜åˆ†ï¼', canvas.width / 2, canvas.height / 2 + 80);
        }
        
        ctx.fillStyle = '#fff';
        ctx.font = '20px Arial';
        ctx.fillText('æŒ‰å›è½¦é”®é‡æ–°å¼€å§‹', canvas.width / 2, canvas.height / 2 + 120);
    }

    requestAnimationFrame(draw);
}

// è¾…åŠ©å‡½æ•°ï¼šåå…­è¿›åˆ¶è½¬RGB
function hexToRgb(hex) {
    hex = hex.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    return `${r}, ${g}, ${b}`;
}

// åˆå§‹åŒ–æ¸¸æˆ
function initGame() {
    updateLevelUI();
    update();
    draw();
}

// å¯åŠ¨æ¸¸æˆ
initGame();
</script>
</body>
</html>
    